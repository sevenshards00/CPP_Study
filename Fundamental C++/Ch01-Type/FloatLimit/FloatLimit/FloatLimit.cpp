/*
* Fundamental C++ - Ch01-Type
* 파일명: FloatLimit.cpp
* 파일 버전: 0.1
* 작성자: Sevenshards
* 작성 일자: 2024-02-19
* 이전 버전 작성 일자:
* 버전 내용: float의 소수 표현 한계
* 이전 버전 내용:
*/

#include <iostream>
using std::cout;

int main()
{
	// 8388608은 비트 구조로 나타내면 다음과 같음
	// 0(부호부) 10010110(지수부) 00000000000000000000000 (가수부)
	// 이걸 계산하면 1.0000000000000000000000000(2) * 2^23 == 100000000000000000000000(2)가 된다.
	// 그리고 유효 숫자인 가수부 23비트를 모두 넘어가게 됨.
	float f1[10] = {
		8388608.0,
		8388608.1,
		8388608.2,
		8388608.3,
		8388608.4,
		8388608.5,
		8388608.6,
		8388608.7,
		8388608.8,
		8388608.9
	};

	cout.precision(32);		// 소수점 자릿수 지정, 32번째 자리까지 출력
	for (int i = 0; i != _countof(f1); ++i)
	{
		cout << f1[i] << '\n';
	}


	// 33554432은 비트 구조로 나타내면 다음과 같음
	// 0(부호부) 10011000(지수부) 00000000000000000000000 (가수부)
	// 이걸 계산하면 1.00000000000000000000000(2) * 2^25 == 10000000000000000000000000(2)가 된다.
	// 이때 두 자릿수만큼 더 이동하기 때문에 뒤에 00이 반드시 붙게 되며 이로 인해 4의 배수만 나타내게 된다.
	// 지수부가 점점 커질수록 오차는 크게 발생함.
	float f2[10] = {
		33554432,
		33554433,
		33554434,
		33554435,
		33554436,
		33554437,
		33554438,
		33554439,
		33554440,
		33554441
	};

	cout.precision(32);
	for (int i = 0; i != _countof(f2); ++i)
	{
		cout << f2[i] << '\n';
	}

	return 0;
}